#include<stdio.h>
// 01.09 리마인드

//저번 주 연산자 하다가 말았네
// 컴퓨터 일 시킨다 > 일감을 박스에 담아서 > 그 박스는 변수 > 변수는 메모리에 담는다.
		// 어떤 것을 담을 수 있는가? - 정수, 실수, 문자
// 정수 = int a; > 컴퓨터는 DataType 변수명;  int는 시스템 의존적이다. 
// int를 정의하기를 컴퓨터가 한 번에 처리할 수 있는 단위 > (x86/64)같은 
		// CPU 안에도 저장 공간이 있다. 그 저장공간을 레지스터라고 한다. x86은 그 레지스터 공간이 32비트 64는 64비트의 레지스터를 갖고 있다. 
			// int형 같은 경우는 시스템에 따라서 달라지기 때문에 확인해야 한다. 
// 정수형 공간을 만들 떄에는 int, short, long이 있다.
	// 정수형은 앞에 unsigned int, unsigned short, unsigned long이 뭍을 수 있다.
		// 그냥이면 0 음 양
		// unsigned 가 붙으면  0 양

//int a; > 메모리 공간에 4byte 할당 해라 / 그 공간을 정수 저장으로 사용할꺼고 / 그 공간을 a로 접근할꺼야


// 실수 (1.2f)  float과 double이 있다. 
// float은 4바이트 double은 8바이트 
// 실수는 최상위 비트는 부호비트 30~22비트는 지수 저장공간 나머지는 가수를 저장하는 공간

// 문자형은 char형과 w_char(2바이트)가 있다. 
// 문자형은 ASCII 코드를 저장하기 위해서 만들었다. 


// 지금까지 일감을 변수를 통해서 전달하는 것을 배웠다. 

//그러면 이제는 일을 시켜야할 때이다.  _ 연산자를 통해서 일을 시킨다.

//		연산자

// 사칙/논리/관계/대입 연산자
//%는 임의의 값을 일정한 범위의 값으로 만들 떄

//관계연산자 > (<,>,<=,>=) 등 이들의 결과는 논리값으로 산출

//논리연산자 피연산자로 데이타 타입이?
	// 논리값 && 논리값
//대입연산자
//	leftValue(공간) = rightValue(변수);
	//+=,/=,*= 등


//조건 연산자 
//int a = 20;
//int b = 30;
//int c = a > b ? 20 : 30;
//그러면 c에는 30이 들어가겠지???
//true나 false가 들어가 있는 식이 있고 true면 앞에 있는 식: false면 뒤에 있는 식이 들어간다.

//이렇게도 쓸 수 있다.a > b ? printf("monster") : printf("asdf1");


//증감연산자
//++, --이렇게 사용한다.
//int a = 20;
//++a; 는 a = a + 1;과 동일하다.
// ++a;는 전위식 a++;는 후위식 그냥 단독적으로 사용하면 둘 다  a의 값을 증가시키는 것은 같은데
//만약에
//int c = ++a;
//c = a++; 이렇게 되면 달라진다. 

int main() {

//	int a = 20;
//	int c = ++a;
//	printf("c= %d, a= %d \n",c, a);
//	c = a++;
//	printf("c= %d, a= %d \n",c, a);
//
//	// 감소연산자 ==
//	 a = 20;
//	 c = --a;
//	printf("c= %d, a= %d \n",c, a);
//	c = a--;
//	printf("c= %d, a= %d \n",c, a);
////---------------------------------------------------------------------------------------------
//			// 비트 연산자 (요즘은 사용빈도가 그리높지 않다.
//
//	//비트 연산자는 비트 단위로 연산을해서 그렇다.
//
//	char a = 3; /*00000011(a)*/
//	char b = 2; /*00000010(b)*/

	//왜 위와 같이 저장되는가?
	//	10진수를 2진수로 변환한다.
	//		즉, 10진수로 되어있는 값을 2로 나누면 알 수 있다. 
	
	 /*00000011(a)*/
	 /*00000010(b)*/
	/*를 & 연산하면 
	   00000010(a&b)*/
	//즉, 2가 나온다. 



	/*00000011(a)*/
	/*00000010(b)*/
  /*| 00000011(a|b)*/

	//이런식으로 계산된다. 이런 단순 계산은 그리 크게 의미가 없고
	//	&는 mask off
	//	|는 mask on할 때 사용된다.
	//		
	//	eg) int a;
	//			a = 101011010101;
	//			&   111111111011
	//				하면 특정비트는 무조건 off가 되는 경우가 발생한다.
	//				이런 것을 mask off라고 한다.

	//옛날에 메모리가 부족하던 시절에서 용량을 줄이기 위해서 비트단위 연산을 했다. 


	//	char light
	//	10101010
	//	비트 마다 전등이 꺼지고 켜지고 값이 들어간다고 해보자 0이되면 꺼지고 1이되면 켜지는
	//	만약에 왼쪽에서 두 번째 전등만 끄려고 하면 
	//	11111101을 & 붙여서 특정 비트를 0으로 만들 수 있다. 이를 mask off라고 한다.

	/*mask on은 특정 비트를 on 할 때 사용한다. 
		10101010에서 왼쪽에서 3번쨰 전등을 무조건 킨다고 하면
		00000100 을 | 연산을 하면 3 번째 전등이 켜지겠지
		이러한 경우에 사용하는 것 mask on이라고 한다.*/
	
	/*~light; 를 하면 비트가 반전된다. 0은 1로 1은 0으로
		01010101이 된다.

		^ (베타적 OR _exclusive or)

		1011010
		^ 1100001

		두 비트가 같으면 0 두 비트가 다르면 1
		연산하면 0111011이 된다.

		int a = 2;
		int b = 3;

		00000010 (2)
		00000011 (3)
	^   00000001 이 된다.*/
	//^	00000011 (3)  다시 b의 값을 ^하면 a의 값이 나온다. 
	//	00000010 (2) 

	//	이런 것 어디에 사용할까? 드래그 해서 박스가 나올 떄 뒤에 배경 색이 바뀌겠지
	//	늘였던걸 줄이면 다시 색의 값이 원래 값으로 돌아가겠지 이걸 ^을 써서 구현한다..?
	//	와 개신기하네 ㅋㅋㅋ
		

			//>> (right shift). << (left shift)

		/*char a = 1;
		
		000000001 에 <<를 하면 00000010 으로 비트를 전체적으로 하나씩 왼쪽으로 민다. 밀려서 바깥으로 나간 비트는 소멸된다 .
		밀린 공간은 0으로 채워진다. 
		다시 >> 하면 000000001*/

	//   <<는 X2, >>는 /2와 결과적으로 같다.


		/*컴퓨터는 뺼셈, 곱셈, 나눗셈을 아나요??   몰라...........ㅋㅋㅋ
	가산기라는 것이 있어서 오로지 덧셈만을 알고 있는 바보야 ㅋㅋ
	뺄셈을 어떻게 해?   보수연산을 통해서 뺼셈을 구현한다. */

				/*<보수법>
		10진수에서 2의 보수는 8 (10을 만드는 수 )
		보수법 복습 한 번 하자??*/


	/*int a = 21;
	int b = 2;

	float c = a / b;*/
	          /*
	정수 / 정수  = 정수
	정수 / 실수  = 실수
		자동으로 형변환(두 개 중에 더 큰 데이터 타입으로 형변환이 된다. )*/
	//만약 정수 / 정수를 실수로 받고 싶으면 둘 중 하나를 (float)으로 형 변환을 해야한다. 

	/*float a = 1.5f;
	int b;*/
	//b = a;

	//실수 타입이 정수형으로 변경되서 들어가는데 강제로 형변환이 일어난다.
	//	이런 경우 컴파일러가 자동적으로 변환해준다.  : 묵시적 형변환
	//	근데 이런 경우 묵시적 형변환을 시키면 안된다.이걸 실수한건지 의도적으로 한 건지 판단하기가 어렵기 때문이다.
	//	저 0.5를 은행프로그램에서 실수 했다고 하면 엄청난  사고가 될 수도 있다.

	//	만약 강제 형변환을 해야한다면 명확히(int) 하는 식으로 쓰는게 좋다.,

	//	b = (int)a;
	// > 명시적 형변환



//		//sizeof 연산자란???
//printf("int  size = %d", sizeof(int));
//double a = 1.2;
//
//printf("a변수의 size = %d", sizeof(a));
////
////데이터 타입의 바이트 크기를 리턴해준다.
////혹은 변수 공간의 바이트 크기를 리턴한다. 
// /*sizeof 는 실행 중에 작동하는 연산자가 아니다. 
//	 컴파일 할 때 작동하는 연산자이다. 
//	 컴파일 할 때 sizeof(int) 가 4로 박혀버린다 이 얘기지???*/
//
//  /*'  ,  '도 연산자*/
//
//printf("monter"), printf("ster");
//이것도 가능하단 얘기임 ,도 연산자라

printf("int size =%d\n" ,sizeof(int));
printf("unsigned int size =%d\n", sizeof(unsigned int));
printf(" int 8 size =%d\n", sizeof(_int8));
printf(" int 16 size =%d\n", sizeof( _int16));
printf(" int  32 size =%d\n", sizeof(_int32));
printf("short size =%d\n", sizeof(short));
printf("long size =%d\n", sizeof(long));
printf("char size =%d\n", sizeof(char));
printf("float size =%d\n", sizeof(float));
printf("double size =%d\n", sizeof(double));

//다른 데이터 형(int8) 들도 머리에 좀 기억을 하는게 좋겠다.

	return 0;
}	